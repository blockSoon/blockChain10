1. ERC721 컨트랙트 구조와 민팅 구조
2. ipfs에 메타데이터를 업로드 pinata를 사용해서 업로드
3. 업로드한 메타데이터를 가지고 nft 민팅 한뒤
4. 오픈씨에서 우리 nft확인하고 거래등록 하면 어떻게 진행되는지
5. 우리 프로젝트에서도 nft 내용과 소유권 이전

# ERC721 표준(nft)

- 대체 불가능한 토큰 모양은 같을수 있는데 고유한 식별자가 있어서 각각의 nft는 대체가 불가능하다. 영화관 가면 노량 영화티켓을 구매함 영화티켓의 이미지는 모두 같은데. 입장코드

# 민팅

- 블록체인 네트워크에서 새로운 토큰을 생성하는 과정 의미한다.
- 우리가 이전에 ERC20 표준을 사용해서 토큰을 생성 해봤고 이번엔 ERC721표준으로 만들어보자.
- 토큰 ERC20은 생성할때 내부 데이터가 중요한게 아니고 갯수에 의미가 있는데
- ERC721(nft)는 생성할때 데이터를 포함시키고 객체의 내용을 가지고 고유한 식별자를 포함하고 있다.
- ERC20 민팅을 하면 갯수를 발행해주었는데 ERC721은 객체의 내용을 구성하는 것 까지가 모두 민팅이다.

{
"id": 고유한 식별자
TokenURL : "객체의 데이터 경로 (json 파일 경로)"
}

- ERC20 소유권
  {
  0x1 : 10000,
  0x2 : 2000,
  0x3 : 50000,
  }

- ERC721 소유권
  {
  1 : 0x1,
  2 : 0x2,
  3 : 0x3
  }

```sh
npx create-react-app erc721
cd erc721
npm i @openzeppelin/contracts
```

```json
# nft
{
    "id" : "고유한 아이디",
    "tokenURL" : "json의 경로"
}

# nft json의 내용
{
    "name" : "nft의 이름",
    "description" : "nft의 설명",
    "image" : "nft의 이미지 경로(ipfs에 업로드된 이미지 경로)",
    "attributes" : [
        // type 같은 nft의 추가 속성을 사용하고 싶을때
    ]
}
```

- 우리가 객체의 내용을 데이터 베이스 같은 중앙화 저장소에 저장한 값으로 NFT를 민팅 할수는 있는데
- 탈중앙화라고 보기 힘들기 때문에
- 분산 파일 시스템 IPFS에 객체의 내용을 업로드하고 이미지도 업로드해서 고유한 CID 해시 URL을 가지고 사용한다.
- IPFS에 파일을 업로드하면 분산 네트워크, 중앙화 서버가 없고 여러 노드들이 분산 네트워크에 파일을 저장한다(안정성)
- 무결성 및 보안 유지
- 업로드하면 파일의 경로는 고유한 주소를 가진다(해시기반)
- 분산 파일 시스템 데이터를 저장하는 프로토콜 P2P 네트워크

- IPFS에 파일을 한번 업로드하면 수정하거나 삭제를 할수 없다. (보관의 안정성)
- 수정을 한다는 의미는 IPFS에 새로운 버전의 파일을 업로드 한다고 보면 된다. 수정된 파일은 새로운 CID(컨텐츠 식별자)를 가지게 된다.

```sh
remixd -s . --remix-ide https://remix.ethereum.org
```


# react pinata
```sh
npm i axios
```

# open sea
- erc721의 컨트랙트 배포인지 transaction의 input 확인해서 앞자리가 0x6080// 721배포 to = null
- transaction의 영수증의 내용을 확인하면 contract Address = CA주소
- 